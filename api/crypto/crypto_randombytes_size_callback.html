<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>crypto.randomBytes(size[, callback]) | Node.js API 文档</title>
  <link rel="icon" sizes="32x32" type="image/png" href="http://static.nodejs.cn/_static/img/favicon.png"><link rel="stylesheet" href="/api/api.css">
  <script>
    document.write('<link href="http://nodejs.cn/api/crypto/'&#32;+&#32;(location.port?'':'//static.nodejs.cn')&#32;+&#32;'/_static/css/api.css?1576756300402" rel="stylesheet">')
  </script>
</head>
<body class="alt apidoc" id="page_api_item">
  <div id="api-section-crypto">
    <div id="content" class="clearfix">
  
      <div id="column1" data-id="__ID__" class="interior">
        <header>
          <h1>crypto.randomBytes(size[, callback])</h1>
          <div id="gtoc">
            <ul>
              <li>v12.14.0</li>
              <li>
                <a href="../crypto.html#crypto_crypto_randombytes_size_callback" name="toc">返回上层文档</a>
              </li>
              <li>
                <a href="https://github.com/nodejscn/node-api-cn/edit/master/crypto/crypto_randombytes_size_callback.md" rel="nofollow" target="_blank">提交修改</a>
              </li>
              <li>
                <a href="http://nodejs.cn/search" name="toc">搜索</a>
              </li>
            </ul>
          </div>
          <hr>
        </header>

        <div id="biz_item"></div>
  
        <div id="apicontent">
          <div id="content_left"><div class="api_metadata">
<details class="changelog"><summary>&#x7248;&#x672C;&#x5386;&#x53F2;</summary>
<table>
<tbody><tr><th>&#x7248;&#x672C;</th><th>&#x53D8;&#x66F4;</th></tr>
<tr><td>v9.0.0</td>
<td><p>Passing <code>null</code> as the <code>callback</code> argument now throws <code>ERR_INVALID_CALLBACK</code>.</p></td></tr>
<tr><td>v0.5.8</td>
<td><p><span>&#x65B0;&#x589E;&#x4E8E;: v0.5.8</span></p></td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>size</code> <a href="http://nodejs.cn/s/SXbo1v" target="_blank" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li>
<p><code>callback</code> <a href="http://nodejs.cn/s/ceTQa6" target="_blank" rel="nofollow" class="type">&lt;Function&gt;</a></p>
<ul>
<li><code>err</code> <a href="http://nodejs.cn/s/qZ873x" target="_blank" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>buf</code> <a href="http://nodejs.cn/s/6x1hD3" target="_blank" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
<li>&#x8FD4;&#x56DE;: <a href="http://nodejs.cn/s/6x1hD3" target="_blank" rel="nofollow" class="type">&lt;Buffer&gt;</a> &#x5982;&#x679C;&#x672A;&#x63D0;&#x4F9B; <code>callback</code> &#x51FD;&#x6570;&#x3002;</li>
</ul><p>&#x751F;&#x6210;&#x52A0;&#x5BC6;&#x5F3A;&#x4F2A;&#x968F;&#x673A;&#x6570;&#x636E;&#x3002;
<code>size</code> &#x53C2;&#x6570;&#x662F;&#x6307;&#x793A;&#x8981;&#x751F;&#x6210;&#x7684;&#x5B57;&#x8282;&#x6570;&#x7684;&#x6570;&#x503C;&#x3002;</p><p>&#x5982;&#x679C;&#x63D0;&#x4F9B; <code>callback</code> &#x51FD;&#x6570;&#xFF0C;&#x5219;&#x8FD9;&#x4E9B;&#x5B57;&#x8282;&#x662F;&#x5F02;&#x6B65;&#x751F;&#x6210;&#x7684;&#x5E76;&#x4E14;&#x4F7F;&#x7528;&#x4E24;&#x4E2A;&#x53C2;&#x6570;&#x8C03;&#x7528; <code>callback</code> &#x51FD;&#x6570;&#xFF1A;<code>err</code> &#x548C; <code>buf</code>&#x3002;
&#x5982;&#x679C;&#x53D1;&#x751F;&#x9519;&#x8BEF;&#xFF0C;&#x5219; <code>err</code> &#x662F;&#x4E00;&#x4E2A; <code>Error</code> &#x5BF9;&#x8C61;&#xFF0C;&#x5426;&#x5219;&#x4E3A; <code>null</code>&#x3002;
<code>buf</code> &#x53C2;&#x6570;&#x662F;&#x5305;&#x542B;&#x751F;&#x6210;&#x5B57;&#x8282;&#x7684; <a href="http://nodejs.cn/s/FP4oTy" rel="nofollow"><code>Buffer</code></a>&#x3002;</p><pre><code class="language-js">// &#x5F02;&#x6B65;&#x7684;&#x3002;
const crypto = require(&apos;crypto&apos;);
crypto.randomBytes(256, (err, buf) =&gt; {
  if (err) throw err;
  console.log(`${buf.length} &#x4F4D;&#x7684;&#x968F;&#x673A;&#x6570;&#x636E;: ${buf.toString(&apos;hex&apos;)}`);
});
</code></pre><p>&#x5982;&#x679C;&#x672A;&#x63D0;&#x4F9B; <code>callback</code> &#x51FD;&#x6570;&#xFF0C;&#x5219;&#x540C;&#x6B65;&#x5730;&#x751F;&#x6210;&#x968F;&#x673A;&#x5B57;&#x8282;&#x5E76;&#x8FD4;&#x56DE;&#x4E3A; <a href="http://nodejs.cn/s/FP4oTy" rel="nofollow"><code>Buffer</code></a>&#x3002;
&#x5982;&#x679C;&#x751F;&#x6210;&#x5B57;&#x8282;&#x9047;&#x5230;&#x95EE;&#x9898;&#xFF0C;&#x5C06;&#x4F1A;&#x629B;&#x51FA;&#x4E00;&#x4E2A;&#x9519;&#x8BEF;&#x3002;</p><pre><code class="language-js">// &#x540C;&#x6B65;&#x7684;&#x3002;
const buf = crypto.randomBytes(256);
console.log(
  `${buf.length} &#x4F4D;&#x7684;&#x968F;&#x673A;&#x6570;&#x636E;: ${buf.toString(&apos;hex&apos;)}`);
</code></pre><p><code>crypto.randomBytes()</code> &#x65B9;&#x6CD5;&#x5C06;&#x5728;&#x83B7;&#x5F97;&#x8DB3;&#x591F;&#x7684;&#x71B5;&#x4E4B;&#x540E;&#x5B8C;&#x6210;&#x3002;
&#x8FD9;&#x901A;&#x5E38;&#x4E0D;&#x4F1A;&#x8D85;&#x8FC7;&#x51E0;&#x6BEB;&#x79D2;&#x3002;
&#x53EA;&#x6709;&#x5728;&#x521A;&#x5F00;&#x542F;&#x65F6;&#x624D;&#x53EF;&#x80FD;&#x4F1A;&#x963B;&#x585E;&#x66F4;&#x4E45;&#xFF0C;&#x56E0;&#x4E3A;&#x6B64;&#x65F6;&#x6574;&#x4E2A;&#x7CFB;&#x7EDF;&#x7684;&#x71B5;&#x4E0D;&#x591A;&#x3002;</p><p>&#x8FD9;&#x4E2A; API &#x4F7F;&#x7528; libuv &#x7684;&#x7EBF;&#x7A0B;&#x6C60;&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x67D0;&#x4E9B;&#x65F6;&#x5019;&#x53EF;&#x80FD;&#x4F1A;&#x4EA7;&#x751F;&#x610F;&#x5916;&#x7684;&#x6027;&#x80FD;&#x95EE;&#x9898;&#xFF0C;&#x67E5;&#x770B; <a href="http://nodejs.cn/s/6DjmgS" rel="nofollow"><code>UV_THREADPOOL_SIZE</code></a> &#x7684;&#x6587;&#x6863;&#x4EE5;&#x4E86;&#x89E3;&#x66F4;&#x591A;&#x4FE1;&#x606F;&#x3002;</p><p><code>crypto.randomBytes()</code> &#x7684;&#x5F02;&#x6B65;&#x7248;&#x672C;&#x5728;&#x5355;&#x4E2A;&#x7EBF;&#x7A0B;&#x6C60;&#x8BF7;&#x6C42;&#x4E2D;&#x6267;&#x884C;&#x3002;
&#x8981;&#x6700;&#x5C0F;&#x5316;&#x7EBF;&#x7A0B;&#x6C60;&#x4EFB;&#x52A1;&#x957F;&#x5EA6;&#x53D8;&#x5316;&#xFF0C;&#x8BF7;&#x5728;&#x6267;&#x884C;&#x6B64;&#x64CD;&#x4F5C;&#x65F6;&#x5BF9;&#x5927;&#x578B;&#x7684; <code>randomBytes</code> &#x8BF7;&#x6C42;&#x8FDB;&#x884C;&#x5206;&#x533A;&#xFF0C;&#x4EE5;&#x5B8C;&#x6210;&#x5BA2;&#x6237;&#x7AEF;&#x8BF7;&#x6C42;&#x3002;</p></div>
          <div id="content_right"><div class="api_metadata">
<details class="changelog"><summary>History</summary>
<table>
<tbody><tr><th>Version</th><th>Changes</th></tr>
<tr><td>v9.0.0</td>
<td><p>Passing <code>null</code> as the <code>callback</code> argument now throws <code>ERR_INVALID_CALLBACK</code>.</p></td></tr>
<tr><td>v0.5.8</td>
<td><p><span>Added in: v0.5.8</span></p></td></tr>
</tbody></table>
</details>
</div><ul>
<li><code>size</code> <a href="http://nodejs.cn/s/SXbo1v" target="_blank" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li>
<p><code>callback</code> <a href="http://nodejs.cn/s/ceTQa6" target="_blank" rel="nofollow" class="type">&lt;Function&gt;</a></p>
<ul>
<li><code>err</code> <a href="http://nodejs.cn/s/qZ873x" target="_blank" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>buf</code> <a href="http://nodejs.cn/s/6x1hD3" target="_blank" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
<li>Returns: <a href="http://nodejs.cn/s/6x1hD3" target="_blank" rel="nofollow" class="type">&lt;Buffer&gt;</a> if the <code>callback</code> function is not provided.</li>
</ul><p>Generates cryptographically strong pseudo-random data. The <code>size</code> argument
is a number indicating the number of bytes to generate.</p><p>If a <code>callback</code> function is provided, the bytes are generated asynchronously
and the <code>callback</code> function is invoked with two arguments: <code>err</code> and <code>buf</code>.
If an error occurs, <code>err</code> will be an <code>Error</code> object; otherwise it is <code>null</code>. The
<code>buf</code> argument is a <a href="http://nodejs.cn/s/FP4oTy" rel="nofollow"><code>Buffer</code></a> containing the generated bytes.</p><pre><code class="language-js">// Asynchronous
const crypto = require(&apos;crypto&apos;);
crypto.randomBytes(256, (err, buf) =&gt; {
  if (err) throw err;
  console.log(`${buf.length} bytes of random data: ${buf.toString(&apos;hex&apos;)}`);
});
</code></pre><p>If the <code>callback</code> function is not provided, the random bytes are generated
synchronously and returned as a <a href="http://nodejs.cn/s/FP4oTy" rel="nofollow"><code>Buffer</code></a>. An error will be thrown if
there is a problem generating the bytes.</p><pre><code class="language-js">// Synchronous
const buf = crypto.randomBytes(256);
console.log(
  `${buf.length} bytes of random data: ${buf.toString(&apos;hex&apos;)}`);
</code></pre><p>The <code>crypto.randomBytes()</code> method will not complete until there is
sufficient entropy available.
This should normally never take longer than a few milliseconds. The only time
when generating the random bytes may conceivably block for a longer period of
time is right after boot, when the whole system is still low on entropy.</p><p>This API uses libuv&apos;s threadpool, which can have surprising and
negative performance implications for some applications; see the
<a href="http://nodejs.cn/s/6DjmgS" rel="nofollow"><code>UV_THREADPOOL_SIZE</code></a> documentation for more information.</p><p>The asynchronous version of <code>crypto.randomBytes()</code> is carried out in a single
threadpool request. To minimize threadpool task length variation, partition
large <code>randomBytes</code> requests when doing so as part of fulfilling a client
request.</p></div>
          <div></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    document.write('<script src="http://nodejs.cn/api/crypto/'&#32;+&#32;(location.port&#32;?&#32;''&#32;:&#32;'//static.nodejs.cn')&#32;+&#32;'/_static/js/api.js?1576756300402"><\/script>');
  </script>
</body>
</html>